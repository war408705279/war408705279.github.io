<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on rm -rf *</title>
    <link>https://war408705279.github.io/blogs/</link>
    <description>Recent content in Blogs on rm -rf *</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://github.com/war408705279/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;404 Not Found&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 23 Apr 2019 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://war408705279.github.io/blogs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>React component 生命周期</title>
      <link>https://war408705279.github.io/blogs/react-component-life/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/react-component-life/</guid>
      <description>React Native 中的 component 和 Android 中的 activity、fragment 等一样，存在声明周期，下面先给出 component 的生命周期图
 ##### getDefaultProps  object getDefaultProps()  执行过一次后，被创建的类会有缓存，映射的值会存在 this.props，前提是这个 prop 不是父组件指定的，这个方法在对象被创建之前执行，因此不能在方法内调用 this.props，另外，注意任何 getDefaultProps() 返回的对象在实例中共享，不是复制
 ##### getInitialState  object getInitialState()  控件加载之前执行，返回值会被用于 state 的初始化值
 ##### componentWillMount（重要）  void componentWillMount()  执行一次，在初始化 render 之前执行，如果在这个方法内调用 setState，render() 知道 state 发生变化，并且执行一次
 ##### render（重要）  ReactElement render()  render 的时候 render() 会被调用
调用 render() 方法时，首先检查 this.props 和 this.state 返回一个子元素，子元素可以是 DOM 组件或者其他自定义复合控件的虚拟实现
如果不想渲染可以返回 null 或者 false，这种场景下，react 渲染一个 &amp;lt;noscript&amp;gt; 标签，当返回 null 或者 false，ReactDOM.</description>
    </item>
    
    <item>
      <title>Makefile 相关知识</title>
      <link>https://war408705279.github.io/blogs/make-file/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/make-file/</guid>
      <description>一些基本概念 代码变成可执行文件，叫做编译。而先编译这个，还是先编译那个（编译顺序的安排），叫做构建
Make 是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建
make 命令在调用的时候格式为：
make 命令  在执行 make 命令的时候，程序会在当前目录下寻找名为 Makefile 或者 makefile 的文件（注：不带后缀名）。然后会查找文件中是否包含该命令，有就会进行执行。如果只写了 make，没有跟后面的命令，则会默认执行 Makefile 中的第一条命令（如果有的话）
Makefile 的基本形式 Makefile 由一系列规则（rules）组成，每条规则的形式如下所示：
&amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt; [tab] &amp;lt;commands&amp;gt;   上面第一行冒号前面的部分，叫做&amp;rdquo;目标&amp;rdquo;（target） 冒号后面的部分叫做&amp;rdquo;前置条件&amp;rdquo;（prerequisites） 第二行必须由一个 tab 键起首，后面跟着&amp;rdquo;命令&amp;rdquo;（commands） &amp;ldquo;目标&amp;rdquo;是必需的，不可省略；&amp;rdquo;前置条件&amp;rdquo;和&amp;rdquo;命令&amp;rdquo;都是可选的，但是两者之中必须至少存在一个  目标（target） 一个目标（target）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔
除了文件名，目标还可以是某个操作的名字，这称为&amp;rdquo;伪目标&amp;rdquo;（phony target）,例如：
clean: rm *.*  上面代码的目标是 clean，它不是文件名，而是一个操作的名字，属于&amp;rdquo;伪目标 &amp;ldquo;，作用是删除所有文件
前置条件 前置条件通常是一组文件名，之间用空格分隔。它指定了&amp;rdquo;目标&amp;rdquo;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 last-modification 时间戳比目标的时间戳新），&amp;rdquo;目标&amp;rdquo;就需要重新构建
命令 命令（commands）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建&amp;rdquo;目标&amp;rdquo;的具体指令，它的运行结果通常就是生成目标文件
每行命令之前必须有一个 tab 键。如果想用其他键，可以用内置变量 .RECIPEPREFIX 声明，例如：</description>
    </item>
    
    <item>
      <title>学习网站 &#43; 文档</title>
      <link>https://war408705279.github.io/blogs/good-good-study/</link>
      <pubDate>Fri, 12 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/good-good-study/</guid>
      <description>前端学习网站推荐  极客标签：http://www.gbtags.com （传送门） 码农周刊：http://weekly.manong.io/issues （传送门） 前端周刊：http://www.feweekly.com/issues （传送门） 慕课网：http://www.imooc.com/ （传送门） div.io：http://div.io （传送门） Hacker News：https://news.ycombinator.com/news （传送门） InfoQ：http://www.infoq.com/ （传送门） w3cplus：http://www.w3cplus.com/ （传送门） Stack Overflow：http://stackoverflow.com/ （传送门） w3school：http://www.w3school.com.cn/ （传送门） mozilla：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript （传送门）  文档推荐  JQuery 基本原理 JavaScript 秘密花园 CSS 参考手册 JavaScript 标准参考教程 ECMAScript 6入门  Github 备注 根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达
格式和内容不断修改更新中
在 github 项目的右上角，有三个按钮，分别是 watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰
当你选择 Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了 pull request、被发起了 issue 等情况你都会收到邮件通知
star 相当于是点赞或收藏，方便以后查找
fork 表示你想要补充完善这个项目的内容</description>
    </item>
    
    <item>
      <title>前端面试题 - 其他</title>
      <link>https://war408705279.github.io/blogs/interview-other/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/interview-other/</guid>
      <description>浏览器内核 说明一：
 IE 浏览器：Trident（IE 内核） 火狐浏览器：Gecko，特点是代码完全公开 Opera 浏览器：前期采用 Presto 内核，现已改用 Google Chrome 的 Blink 内核 Safari 浏览器：Webkit 内核，Webkit 内核是 Chrome 内核的原型 Chrome 浏览器：采用 Blink 内核，是 Google 和 Opera Software 开发的浏览器排版引擎  说明二：
 Trident 内核：IE，MaxThon，TT，The World，360，搜狗浏览器等 [又称 MSHTML] Gecko 内核：Netscape6 及以上版本，FF，MozillaSuite / SeaMonkey 等 Presto 内核：Opera7 及以上 [Opera 内核原为：Presto，现为：Blink] Webkit 内核：Safari，Chrome等 [Chrome 的：Blink（WebKit 的分支）]  详细文章：传送门
介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎（layout engineer 或 Rendering Engine）和 JS 引擎
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
JS 引擎则：解析和执行 javascript 来实现网页的动态效果</description>
    </item>
    
    <item>
      <title>前端面试题 - 请求</title>
      <link>https://war408705279.github.io/blogs/interview-request/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/interview-request/</guid>
      <description>http 状态码 100-199：用于指定客户端相应的某些动作，服务器接收到请求，需要请求者继续执行操作
200-299：用于表示请求成功
300-399：用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。重定向，需要进一步的操作以完成请求
400-499：用于指出客户端的错误，请求包含语法 错误或无法完成请求。400 - 客户端请求语法有错误，服务器无法理解；401 - 当前请求需要用户验证；403 - 服务器理解请求客户端的请求，但是拒绝执行此请求；404 - 服务器无法根据客户端的请求找到资源（网页）
500-599：服务器端错误。500 - 服务器内部错误，无法完成请求；501 - 服务器不支持请求的功能；502 - 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求；503 - 服务不可用
Ajax 中 GET 和 POST 方法的区别 GET 和 POST 都是向服务器发送的一种请求，只是发送机制不同  GET 请求会将参数跟在 URL 后进行传递，而 POST 请求则是作为 HTTP 消息的实体内容发送给 WEB 服务器。当然在 Ajax 请求中，这种区别对用户是不可见的
 首先是 GET 方式提交的数据最多只能是 1024 字节，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。*这个限制是特定的浏览器及服务器对它的限制*。IE 对 URL 长度的限制是 2083 字节（2K+35）。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度</description>
    </item>
    
    <item>
      <title>如何使用 Git&#43;Hugo 搭建属于自己的博客网站</title>
      <link>https://war408705279.github.io/blogs/hugo/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/hugo/</guid>
      <description>平时在开发过程中多多少少会有一些积累，这个时候就想把这些积累写成博客，一是当做自己本身的沉淀，二是可以把这些积累分享出去。但是根据常规思路搭建一个属于自己的博客网站又太麻烦，这个时候可以使用 Github + Hugo 快速搭建一套属于自己的博客网站，下面就对搭建流程做一个简单的介绍
*注*：以下步骤以在 macOS 上的操作为例，其它操作系统类似，只是一些工具和命令有区别
注册一个 Github 账号 首先你要有一个 Github 账号，这里就不赘述了，毕竟注册 Github 的流程不复杂
创建一个 repo 新建一个 GitHub repository，库名为 username.github.io，username 即你的 GitHub 账号 username
例如我创建的 repo 就叫 war408705279.github.io
安装 Hugo Hugo 安装的官方文档 传送门
可以使用 Homebrew 进行快速的安装，命令如下
# 安装 hugo brew install hugo # 查看 hugo 版本信息 hugo version 新建一个 Hugo 网站 cd 到你想保存 Hugo 网站的目录下，运行下面的命令
cd /code hugo new site myblog 命令运行成功后会在当前目录（/code）下创建一个名为 myblog 的文件夹，里面保存着网站的初始文件。注意这里不用重复创建 myblog 文件夹
选择 Hugo 主题并克隆至本地目录 Hugo 一个比较棒的功能是可以让用户自定义博客主题</description>
    </item>
    
    <item>
      <title>前端面试题 - JS</title>
      <link>https://war408705279.github.io/blogs/interview-js/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/interview-js/</guid>
      <description>前端 JS 面试题积累 JS 获取 URL 中的 Query 参数 getQueryString(name) { var reg = new RegExp(&amp;#39;(^|&amp;amp;)&amp;#39; + name + &amp;#39;=([^&amp;amp;]*)(&amp;amp;|$)&amp;#39;, &amp;#39;i&amp;#39;); var r = routerStore.location.search.substr(1).match(reg); if (r !== null) { return unescape(r[2]); } return null; } // 调用的时候传递 query 参数的 key 值进去  // 例如需要获取 url 中 id 对应的值  var id = getQueryString(&amp;#39;id&amp;#39;)  call() 和 apply() 的异同 call 和 apply 的基本作用都是改变对象执行的上下文
call 的基本使用
function.call(obj [, arg1 [, arg2[, [, argN]]]]])  说明</description>
    </item>
    
    <item>
      <title>学习网站推荐</title>
      <link>https://war408705279.github.io/blogs/learn-website/</link>
      <pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/learn-website/</guid>
      <description>前端学习网站推荐  极客标签：http://www.gbtags.com （传送门） 码农周刊：http://weekly.manong.io/issues （传送门） 前端周刊：http://www.feweekly.com/issues （传送门） 慕课网：http://www.imooc.com/ （传送门） div.io：http://div.io （传送门） Hacker News：https://news.ycombinator.com/news （传送门） InfoQ：http://www.infoq.com/ （传送门） w3cplus：http://www.w3cplus.com/ （传送门） Stack Overflow：http://stackoverflow.com/ （传送门） w3school：http://www.w3school.com.cn/ （传送门） mozilla：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript （传送门）  文档推荐  JQuery 基本原理 JavaScript 秘密花园 CSS 参考手册 JavaScript 标准参考教程 ECMAScript 6入门  备注 根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达
格式和内容不断修改更新中
在 github 项目的右上角，有三个按钮，分别是 watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰
当你选择 Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了 pull request、被发起了 issue 等情况你都会收到邮件通知
star 相当于是点赞或收藏，方便以后查找
fork 表示你想要补充完善这个项目的内容</description>
    </item>
    
    <item>
      <title>前端面试题 - CSS</title>
      <link>https://war408705279.github.io/blogs/interview-css/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/interview-css/</guid>
      <description>前端 CSS 面试题积累 CSS 的盒子模型 有两种盒子模型
 IE 盒子模型：content 部分包含了 border 和 padding 标准 W3C 盒子模型：包含内容（content）、填充（padding）、边界（margin）、边框（border）  CSS 选择符  id 选择器（#id） 类选择器（.myclassname） 标签选择器（div，h1，p） 相邻选择器（h1+p） 子选择器（ul &amp;gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel = &amp;ldquo;external&amp;rdquo;]） 伪类选择器（a:hover, li:nth-child） 可继承的样式：font-size、font-family、color 等 不可继承的样式：border、padding、margin、width、height 等 优先级就近原则，同权重情况下样式定义最近者为准 优先级为：!important &amp;gt; id 选择器 &amp;gt; class 选择器 &amp;gt; 标签选择器  nth-child 和 nth-of-type 之间的差异 nth-child：按照个数来计算
看如下的例子
&amp;lt;style&amp;gt; p:nth-child(2), p:nth-child(7){ color:red; } &amp;lt;/style&amp;gt; &amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;这是段落&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;这是段落&amp;lt;/p&amp;gt; &amp;lt;span&amp;gt;这是 span&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;这是 span&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;这是 span&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;这是段落&amp;lt;/p&amp;gt; 效果如下所示</description>
    </item>
    
    <item>
      <title>前端面试题 - HTML</title>
      <link>https://war408705279.github.io/blogs/interview-html/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://war408705279.github.io/blogs/interview-html/</guid>
      <description>前端 HTML 面试题积累 语义化的 HTML 说明一：
 直观的认识标签对于搜索引擎的抓取有好处，用正确的标签做正确的事情 HTML 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析 在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO 使阅读源代码的人更容易将网站分块，便于阅读维护理解  说明二：
 用正确的标签做正确的事情 HTML 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解  &amp;lt;!DOCTYPE html&amp;gt; 标签 H5 不基于 SGML，因此不需要对 DTD（document type definition）进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.0 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型
Doctype 作用？标准模式与兼容模式各有什么区别?  &amp;lt;!DOCTYPE&amp;gt; 声明位于 HTML 文档中的第一行，处于  标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现
 标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作
  行内元素有哪些？块级元素有哪些？ 空（void）元素有那些？ 首先：CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值，如 div 的 display 默认值为 “block”，则为“块级”元素；span 默认 display 属性值为 “inline”，是“行内”元素</description>
    </item>
    
  </channel>
</rss>