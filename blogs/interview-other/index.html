<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Zhazha ">
<meta name="description" content="浏览器内核 说明一：
 IE 浏览器：Trident（IE 内核） 火狐浏览器：Gecko，特点是代码完全公开 Opera 浏览器：前期采用 Presto 内核，现已改用 Google Chrome 的 Blink 内核 Safari 浏览器：Webkit 内核，Webkit 内核是 Chrome 内核的原型 Chrome 浏览器：采用 Blink 内核，是 Google 和 Opera Software 开发的浏览器排版引擎  说明二：
 Trident 内核：IE，MaxThon，TT，The World，360，搜狗浏览器等 [又称 MSHTML] Gecko 内核：Netscape6 及以上版本，FF，MozillaSuite / SeaMonkey 等 Presto 内核：Opera7 及以上 [Opera 内核原为：Presto，现为：Blink] Webkit 内核：Safari，Chrome等 [Chrome 的：Blink（WebKit 的分支）]  详细文章：传送门
介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎（layout engineer 或 Rendering Engine）和 JS 引擎
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
JS 引擎则：解析和执行 javascript 来实现网页的动态效果"/>
<meta name="keywords" content="HTML5, Javascript, css, front-end, blog"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://war408705279.github.io/blogs/interview-other/" />


    <title>
        
            前端面试题 - 其他 :: rm -rf *  — Welcome to my blog
        
    </title>



<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro" rel="stylesheet" type="text/css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://war408705279.github.io/scss/main.min.099699ab246bf26f50616f7c9f00c79d46110459d1bd727b2d07d6fc09ece082.css">



<link rel="apple-touch-icon" sizes="180x180" href="https://war408705279.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://war408705279.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://war408705279.github.io/favicon-16x16.png">
<link rel="manifest" href="https://war408705279.github.io/site.webmanifest">
<link rel="mask-icon" href="https://war408705279.github.io/safari-pinned-tab.svg" color="">
<link rel="shortcut icon" href="https://war408705279.github.io/favicon.ico">
<link rel="shortcut icon" href="https://github.githubassets.com/favicon.ico">

<meta itemprop="name" content="前端面试题 - 其他">
<meta itemprop="description" content="浏览器内核 说明一：
 IE 浏览器：Trident（IE 内核） 火狐浏览器：Gecko，特点是代码完全公开 Opera 浏览器：前期采用 Presto 内核，现已改用 Google Chrome 的 Blink 内核 Safari 浏览器：Webkit 内核，Webkit 内核是 Chrome 内核的原型 Chrome 浏览器：采用 Blink 内核，是 Google 和 Opera Software 开发的浏览器排版引擎  说明二：
 Trident 内核：IE，MaxThon，TT，The World，360，搜狗浏览器等 [又称 MSHTML] Gecko 内核：Netscape6 及以上版本，FF，MozillaSuite / SeaMonkey 等 Presto 内核：Opera7 及以上 [Opera 内核原为：Presto，现为：Blink] Webkit 内核：Safari，Chrome等 [Chrome 的：Blink（WebKit 的分支）]  详细文章：传送门
介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎（layout engineer 或 Rendering Engine）和 JS 引擎
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
JS 引擎则：解析和执行 javascript 来实现网页的动态效果">


<meta itemprop="datePublished" content="2019-04-10T00:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2019-04-10T00:00:00&#43;08:00" />
<meta itemprop="wordCount" content="1008">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://war408705279.github.io"/>

<meta name="twitter:title" content="前端面试题 - 其他"/>
<meta name="twitter:description" content="浏览器内核 说明一：
 IE 浏览器：Trident（IE 内核） 火狐浏览器：Gecko，特点是代码完全公开 Opera 浏览器：前期采用 Presto 内核，现已改用 Google Chrome 的 Blink 内核 Safari 浏览器：Webkit 内核，Webkit 内核是 Chrome 内核的原型 Chrome 浏览器：采用 Blink 内核，是 Google 和 Opera Software 开发的浏览器排版引擎  说明二：
 Trident 内核：IE，MaxThon，TT，The World，360，搜狗浏览器等 [又称 MSHTML] Gecko 内核：Netscape6 及以上版本，FF，MozillaSuite / SeaMonkey 等 Presto 内核：Opera7 及以上 [Opera 内核原为：Presto，现为：Blink] Webkit 内核：Safari，Chrome等 [Chrome 的：Blink（WebKit 的分支）]  详细文章：传送门
介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎（layout engineer 或 Rendering Engine）和 JS 引擎
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
JS 引擎则：解析和执行 javascript 来实现网页的动态效果"/>



<meta property="article:published_time" content="2019-04-10 00:00:00 &#43;0800 CST" />









    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://war408705279.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ rm -rf *</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://war408705279.github.io/blogs/">博客</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://war408705279.github.io/blogs/interview-other/">前端面试题 - 其他</a></h2>

            

            <div class="post-content">
                

<h4 id="浏览器内核">浏览器内核</h4>

<p>说明一：</p>

<ul>
<li>IE 浏览器：Trident（IE 内核）</li>
<li>火狐浏览器：Gecko，特点是代码完全公开</li>
<li>Opera 浏览器：前期采用 Presto 内核，现已改用 Google Chrome 的 Blink 内核</li>
<li>Safari 浏览器：Webkit 内核，Webkit 内核是 Chrome 内核的原型</li>
<li>Chrome 浏览器：采用 Blink 内核，是 Google 和 Opera Software 开发的浏览器排版引擎</li>
</ul>

<p>说明二：</p>

<ul>
<li>Trident 内核：IE，MaxThon，TT，The World，360，搜狗浏览器等 [又称 MSHTML]</li>
<li>Gecko 内核：Netscape6 及以上版本，FF，MozillaSuite / SeaMonkey 等</li>
<li>Presto 内核：Opera7 及以上 [Opera 内核原为：Presto，现为：Blink]</li>
<li>Webkit 内核：Safari，Chrome等 [Chrome 的：Blink（WebKit 的分支）]</li>
</ul>

<p>详细文章：<a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" title="浏览器内核的解析和对比" target="_blank">传送门</a></p>

<h4 id="介绍一下你对浏览器内核的理解">介绍一下你对浏览器内核的理解？</h4>

<p>主要分成两部分：渲染引擎（layout engineer 或 Rendering Engine）和 JS 引擎</p>

<p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</p>

<p>JS 引擎则：解析和执行 javascript 来实现网页的动态效果</p>

<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎</p>

<h4 id="ie6-bug-的解决方法">IE6 BUG 的解决方法</h4>

<ul>
<li>由 float 引起的双边距 BUG，使用 display 解决</li>
<li>由 float 引起的 3 像素问题，使用 display: inline -3px</li>
<li>超链接 hover 点击后失效，使用正确的书写顺序 link visited hover active</li>
<li>IE z-index 问题，给父级添加 position: relative</li>
<li>png 透明，使用 js 代码进行修改</li>
<li>min-height 最小高度，使用 !important 解决</li>
<li>select 在 IE6 下遮盖，使用 iframe 嵌套</li>
<li>为什么没有办法定义 1px 左右的宽度容器，是由 IE6 默认的行高造成的，使用样式 overflow: hidden, zoom: 0.08; line-height: 1px; 解决</li>
</ul>

<h4 id="react-的特点">React 的特点</h4>

<ul>
<li>声明式设计</li>
<li>高效：通过对 DOM 的模拟，最大限度的减少与 DOM 的交互</li>
<li>灵活：可以与已知的框架或库很好的配合</li>
<li>JSX：是 js 语法的扩展，不一定使用，但建议用</li>
<li>组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中</li>
<li>单向响应的数据流：React 实现了单向响应的数据流，从而减少了重复代码，这也是解释了它为什么比传统数据绑定更简单</li>
</ul>

<h4 id="vue-的特性">Vue 的特性</h4>

<ul>
<li>轻量级框架</li>
<li>MVVM 框架</li>
<li>数据驱动</li>
<li>组件化</li>
<li>双向数据绑定</li>
<li>指令</li>
<li>插件化</li>
<li>轻量、简洁、高效、快速、模块友好</li>
</ul>

<h4 id="bootstrap-的特点">Bootstrap 的特点</h4>

<ul>
<li>跨设备、跨浏览器，可以兼容所有现在浏览器，包括比较诟病的 IE7、8</li>
<li>响应式布局，不但支持 PC 端的各种分辨率，还支持移动端 pad，手机等屏幕的响应式切换显示</li>
<li>提供全面的组件，Bootstrap 提供了实用性很强的组件，包括：导航、标签、工具条、按钮等</li>
<li>内置 jquery 插件</li>
<li>支持 HTML5、CSS3</li>
<li>支持 less 动态样式</li>
</ul>

<h4 id="node">Node</h4>

<p>Node 的使用场景：高并发、聊天、实时消息推送</p>

<h4 id="性能优化的方法">性能优化的方法</h4>

<ul>
<li>减少 http 请求次数：CSS、JS 等源码压缩，图片大小控制合适，data 缓存，图片服务器</li>
<li>前端模版 JS + 数据，较少由于 HTML 标签导致的带宽浪费，前端用变量保存 ajax 请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 JS 性能</li>
<li>当需要设置的样式很多时设置 className，而不是直接操作 style</li>
<li>少用全局变量、缓存 DOM 节点查找的结果，减少 IO 读取操作</li>
<li>避免使用 CSS Expression（css 表达式），又称动态属性</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</li>
<li>避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示效率慢</li>
</ul>

<h4 id="前端优化">前端优化</h4>

<p>在不影响功能和体验的情况下</p>

<p>能在浏览器执行的不要在服务器执行</p>

<p>能在缓存服务器上直接返回的不要到应用服务器</p>

<p>程序能直接取得结果的不要到外部取得</p>

<p>本机内能取得的数据不要到远程取</p>

<p>内存能取到的不要到磁盘取</p>

<p>缓存中有的数据不要去数据库查询</p>

<h4 id="一个页面从输入-url-到页面加载显示完成-这个过程中都发生了什么">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么</h4>

<ul>
<li>查找浏览器缓存</li>
<li>DNS 解析、查找该域名对应的 IP 地址、重定向（301）、发出第二个 GET 请求</li>
<li>进行 HTTP 协议会话</li>
<li>客户端发送报头（请求报头）</li>
<li>文档开始下载</li>
<li>文档树建立，根据标记请求所需指定 MIME 类型的文件</li>
<li>文件显示</li>
</ul>

<p>浏览器这边做的工作大致分为以下几步</p>

<ul>
<li>加载：根据请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）</li>
<li>解析：对加载到的资源（HTML、JS、CSS 等）进行语法解析，建议相应的内部数据结构（比如 HTML 的 DOM 树，JS 的（对象）属性表，CSS 的样式规则等等）</li>
</ul>

<h4 id="vue-和-angularjs-的异同">Vue 和 AngularJS 的异同</h4>

<p>相同点</p>

<ul>
<li>都支持指令：内置指令和自定义指令</li>
<li>都支持过滤器：内置过滤器和自定义过滤器</li>
<li>都支持双向数据绑定</li>
<li>都不支持低端浏览器</li>
</ul>

<p>不同点</p>

<ul>
<li>AngularJS 的学习成本高</li>
<li>在性能上，AngularJS 依赖对数据做脏检查，所以 Watcher 越多越慢</li>
</ul>

<h4 id="vue-和-react-的异同">Vue 和 React 的异同</h4>

<p>相同点</p>

<ul>
<li>React 采用特殊的 JSX 语法，Vue 在组件开发中也推崇编写 .vue 特殊文件格式，对文件内容有一定的约定，两者都需要编译后使用</li>
<li>二者的中心思想都是一切都是组件，组件实例之间可以嵌套</li>
<li>都提供合理的钩子函数，可以让开发者定制化地去处理需求</li>
<li>都不内置 Ajax、Route 等功能到核心包，而是以插件的方式加载</li>
<li>组件开发中都支持 mixins 的特性</li>
</ul>

<p>不同点</p>

<ul>
<li>React 依赖 virtual DOM，而 Vue 使用的是 DOM 模版，React 采用的 virtual DOM 会对渲染出来的结果做脏检查</li>
<li>Vue 在模板中提供了指令，过滤器等，可以非常方便、快捷的操作 DOM</li>
</ul>

<h4 id="vue-生命周期">Vue 生命周期</h4>

<p>如下图所示</p>

<p><img src="https://war408705279.github.io/images/blogs/vue-lifecycle.png" alt="Vue 生命周期" title="Vue 生命周期" /></p>

<h4 id="react-生命周期">React 生命周期</h4>

<h5 id="实例化">实例化</h5>

<p>首次实例化</p>

<ul>
<li>getDefaultProps</li>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>

<p>实例化完成后的更新</p>

<ul>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>

<h5 id="存在期">存在期</h5>

<p>组件已存在时的状态改变</p>

<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>

<p>销毁 &amp; 清理期</p>

<ul>
<li>componentWillUnmount</li>
</ul>

<h5 id="说明">说明</h5>

<p>生命周期共提供了 10 个不同的 API</p>

<ul>
<li>getDefaultProps</li>
</ul>

<p>作用于组件类，只调用一次，返回对象用于设置默认的 props，对于引用值，会在实例中共享</p>

<ul>
<li>getInitialState</li>
</ul>

<p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的 state，此时可以访问 this.props</p>

<ul>
<li>componentWillMount</li>
</ul>

<p>在完成首次渲染之前调用，此时仍可以修改组件的 state</p>

<ul>
<li>render</li>
</ul>

<p>必选的方法，创建虚拟 DOM，该方法具有特殊的规则</p>

<ul>
<li>只能通过 this.props 和 this.state 访问数据</li>
<li>可以返回 null、false 或任何 React 组件</li>
<li>只能出现一个顶级组件（不能返回数组）</li>
<li>不能改变组件的状态</li>

<li><p>不能修改 DOM 的输出</p></li>

<li><p>componentDidMount</p></li>
</ul>

<p>真实的 DOM 被渲染出来后调用，在该方法中可通过 this.getDOMNode() 访问到真实的 DOM 元素。此时已可以使用其他类库来操作这个 DOM</p>

<p>在服务端中，该方法不会被调用</p>

<ul>
<li>componentWillReceiveProps</li>
</ul>

<p>组件接收到新的 props 时调用，并将其作为参数 nextProps 使用，此时可以更改组件 props 及 state</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">componentWillReceiveProps</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">nextProps</span><span class="p">.</span><span class="nx">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="nx">bool</span><span class="o">:</span> <span class="kc">true</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>shouldComponentUpdate</li>
</ul>

<p>组件是否应当渲染新的 props 或 state，返回 false 表示跳过后续的生命周期方法，通常不需要使用以避免出现 bug。在出现应用的瓶颈时，可通过该方法进行适当的优化</p>

<p>在首次渲染期间或者调用了 forceUpdate 方法后，该方法不会被调用</p>

<ul>
<li>componentWillUpdate</li>
</ul>

<p>接收到新的 props 或者 state 后，进行渲染之前调用，此时不允许更新 props 或 state</p>

<ul>
<li>componentDidUpdate</li>
</ul>

<p>完成渲染新的 props 或者 state 后调用，此时可以访问到新的 DOM 元素</p>

<ul>
<li>componentWillUnmount</li>
</ul>

<p>组件被移除之前被调用，可以用于做一些清理工作，在 componentDidMount 方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</p>

<h4 id="请描述一下-cookies-sessionstorage-和-localstorage-的区别">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4>

<p>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p>

<p>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递</p>

<p>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</p>

<p>存储大小：</p>

<ul>
<li>cookie 数据大小不能超过 4k</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</li>
</ul>

<p>有期时间：</p>

<ul>
<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>

<h4 id="什么是-quirks-模式">什么是 Quirks 模式</h4>

<p>简单来说，Quirks Mode 就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式</p>

<p>Quirks Mode 是一种浏览器（像 IE，Firefox，Opera）操作模式。 从根本上说，怪异模式（也称之为兼容模式）意味着一个相对新的浏览器故意模拟许多在旧浏览器中存在的 bug，特别是在 IE4 和 IE5 中</p>

<p>更多可以查看 <a href="https://www.jianshu.com/p/86be91568847" title="Quirks 模式是什么？它和 Standards 模式有什么区别" target="_blank">传送门</a></p>

<h4 id="如何实现浏览器内多个标签页之间的通信-阿里">如何实现浏览器内多个标签页之间的通信?（阿里）</h4>

<p>WebSocket、SharedWorker</p>

<p>也可以调用 localstorge、cookies 等本地存储方式</p>

<p>localstorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件</p>

<p>我们通过监听事件，控制它的值来进行页面信息通信</p>

<p>注意 Quirks（怪癖模式，诡异模式，怪异模式）：Safari 在<strong>无痕模式</strong>下设置 localstorge 值时会抛出 QuotaExceededError 的异常</p>

<h4 id="websocket-如何兼容低浏览器-阿里">webSocket 如何兼容低浏览器？（阿里）</h4>

<ul>
<li>Adobe Flash Socket</li>
<li>ActiveX HTMLFile（IE）</li>
<li>基于 multipart 编码发送 XHR</li>
<li>基于长轮询的 XHR</li>
</ul>

<h4 id="如何在页面上实现一个圆形的可点击区域">如何在页面上实现一个圆形的可点击区域？</h4>

<ul>
<li>map + area 或者 svg</li>
<li>border-radius</li>
<li>纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
</ul>

<h4 id="网页验证码是干嘛的-是为了解决什么安全问题">网页验证码是干嘛的，是为了解决什么安全问题</h4>

<p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</p>

<p>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</p>

<h3 id="前端框架">前端框架</h3>

<h4 id="react-使用场景">React 使用场景？</h4>

<p>逻辑复杂单页应用，偏中后台管理系统，纯展示性的 UI 页面不合适的时候使用 React</p>

<h4 id="描述一下-react-生命周期">描述一下 React 生命周期</h4>

<p>渲染过程调用到的生命周期函数，主要几个要知道</p>

<ul>
<li>constructor</li>
<li>getInitialState</li>
<li>getDefaultProps</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>

<p>更新过程</p>

<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>

<p>卸载过程</p>

<ul>
<li>componentWillUnmount</li>
</ul>

<h4 id="实现组件有哪些方式">实现组件有哪些方式？</h4>

<ul>
<li>React.createClass 使用 API 来定义组件</li>
<li>React ES6 class component 用 ES6 的 class 来定义组件</li>
<li>Functional stateless component 通过函数定义无状态组件</li>
</ul>

<h4 id="应该在-react-生命周期的什么阶段发出-ajax-请求-为什么">应该在 React 生命周期的什么阶段发出 Ajax 请求，为什么？</h4>

<p>Ajax 请求应在 componentDidMount 函数中进行请求</p>

<h4 id="shouldcomponentupdate-函数有什么作用">shouldComponentUpdate 函数有什么作用？</h4>

<p>shouldComponentUpdate 是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation 的最终目的是尽可能以最有效的方式去根据新的 state 更新 UI</p>

<p>如果你已经知道 UI 的哪些状态无需进行改变，就没必要去让 React 去判断它是否该改变。让 shouldComponentUpdate 返回 false, React 就会让当前的组件和其子组件保持不变</p>

<h4 id="当组件的-setstate-函数被调用之后-发生了什么">当组件的 setState 函数被调用之后，发生了什么？</h4>

<p>React 会做的第一件事就是把你传递给 setState 的参数对象合并到组件原先的 state。这个事件会导致一个 reconciliation（调和）的过程。reconciliation 的最终目标就是，尽可能以最高效的方法，去基于新的 state 来更新 UI。为了达到这个目的，React 会构建一个 React 元素树（你可以把这个想象成一个表示 UI 的一个对象）。一旦这个树构建完毕，React 为了根据新的 state 去决定 UI 要怎么进行改变，它会找出这棵新树和旧树的不同之处。React 能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染</p>

<h4 id="为什么循环产生的组件中要利用上-key-这个特殊的-prop">为什么循环产生的组件中要利用上 key 这个特殊的 prop？</h4>

<p>keys 负责帮助 React 跟踪列表中哪些元素被改变 / 添加 / 移除。React 利用子元素的 key 在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有 keys，React 也就不知道当前哪一个的 item 被移除了</p>

<h4 id="refs-是什么">refs 是什么？</h4>

<p>Refs 是能访问 DOM 元素或组件实例的一个函数</p>

<h4 id="什么时候应该选择用-class-实现一个组件-什么时候用一个函数实现一个组件">什么时候应该选择用 class 实现一个组件，什么时候用一个函数实现一个组件？</h4>

<p>组件用到了 state 或者用了生命周期函数，那么就该使用 Class component。其他情况下，应使用 Functional component</p>

<h4 id="并不是父子关系的组件-如何实现相互的数据通信">并不是父子关系的组件，如何实现相互的数据通信？</h4>

<p>使用父组件，通过 props 将变量传入子组件（如通过 refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过 props 传入另一个子组件）</p>

<h4 id="用过-react-技术栈中哪些数据流管理库">用过 React 技术栈中哪些数据流管理库？</h4>

<p>Redux、Dva、mobx 等</p>

<h4 id="页面重构怎么操作">页面重构怎么操作？</h4>

<p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为</p>

<p>也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI</p>

<p>对于传统的网站来说重构通常是：</p>

<ul>
<li>表格（table）布局改为 DIV + CSS</li>
<li>使网站前端兼容于现代浏览器（针对于不合规范的 CSS、如对 IE6 有效的兼容）</li>
<li>对于移动平台的优化</li>
<li>针对于 SEO 进行优化</li>
<li>深层次的网站重构应该考虑的方面</li>
<li>减少代码间的耦合</li>
<li>让代码保持弹性</li>
<li>严格按规范编写代码</li>
<li>设计可扩展的 API</li>
<li>代替旧有的框架、语言（如 VB）</li>
<li>增强用户体验</li>
<li>通常来说对于速度的优化也包含在重构中</li>
<li>压缩 JS、CSS、image 等前端资源（通常是由服务器来解决）</li>
<li>程序的性能优化（如数据读写）</li>
<li>采用 CDN 来加速资源加载</li>
<li>对于 JS DOM 的优化</li>
<li>HTTP 服务器的文件缓存</li>
</ul>

<h4 id="什么叫优雅降级和渐进增强">什么叫优雅降级和渐进增强？</h4>

<p>优雅降级：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的 IE 进行降级处理了，使之在旧式浏览器上以某种形式降级体验却不至于完全不能用，如：border-shadow</p>

<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能，向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用 flash 上传，但如果浏览器支持 HTML5 的文件上传功能，则使用 HTML5 实现更好的体验</p>

<h4 id="是否了解公钥加密和私钥加密">是否了解公钥加密和私钥加密</h4>

<p>一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证</p>

<p>HTTP 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密</p>

<h4 id="web-应用从服务器主动推送-data-到客户端有那些方式">WEB 应用从服务器主动推送 Data 到客户端有那些方式？</h4>

<ul>
<li>HTML5 提供的 Websocket</li>
<li>不可见的 iframe</li>
<li>WebSocket 通过 Flash</li>
<li>XHR 长时间连接</li>
<li>XHR Multipart Streaming</li>
<li><code>&lt;script&gt;</code>标签的长时间连接（可跨域）</li>
</ul>

<h4 id="对-node-的优点和缺点提出了自己的看法">对 Node 的优点和缺点提出了自己的看法？</h4>

<ul>
<li><p>优点：因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。此外，与 Node 代理服务器交互的客户端代码是由 Javascript 语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情</p></li>

<li><p>缺点：Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子</p></li>
</ul>

<h4 id="你有用过哪些前端性能优化的方法">你有用过哪些前端性能优化的方法？</h4>

<ul>
<li>减少 http 请求次数：CSS Sprites，JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存，图片服务器</li>
<li>前端模板 + JS + 数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 Javascript 性能</li>
<li>当需要设置的样式很多时设置 className 而不是直接操作 style</li>
<li>少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作</li>
<li>避免使用 CSS Expression（css 表达式)，又称 Dynamic properties（动态属性）</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</li>
<li>避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div + css 布局慢</li>
</ul>

<p>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如 join 查询），减少磁盘 IO 指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法 &ldquo;优化&rdquo; 的</p>

<h4 id="对前端工程师这个职位是怎么样理解的-它的前景会怎么样">对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</h4>

<p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近</p>

<ul>
<li>实现界面交互</li>
<li>提升用户体验</li>
<li>有了 Node.js，前端可以实现服务端的一些事情</li>
</ul>

<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好</p>

<ul>
<li>参与项目，快速高质量完成实现效果图，精确到 1px</li>
<li>与团队成员，UI 设计，产品经理的沟通</li>
<li>做好的页面结构，页面重构和用户体验</li>
<li>处理 hack，兼容、写出优美的代码格式</li>
<li>针对服务器的优化、拥抱最新前端技术</li>
</ul>

<h4 id="平时如何管理你的项目">平时如何管理你的项目？</h4>

<p>大致遵循以下几点</p>

<ul>
<li>先期团队必须确定好全局样式（global.css），编码模式（utf-8）等</li>
<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）</li>
<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）</li>
<li>页面进行标注（例如 页面 模块 开始和结束）</li>
<li>CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）</li>
<li>JS 分文件夹存放 命名以该 JS 功能为准的英文翻译</li>
<li>图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</li>
</ul>

<h4 id="移动端-android-ios-怎么做好用户体验">移动端（Android IOS）怎么做好用户体验？</h4>

<ul>
<li>清晰的视觉纵线</li>
<li>信息的分组、极致的减法</li>
<li>利用选择代替输入</li>
<li>标签及文字的排布方式</li>
<li>依靠明文确认密码</li>
<li>合理的键盘利用</li>
</ul>

<h3 id="其他">其他</h3>

<p>一些问题，持续更新答案</p>

<h4 id="react-router-路由的实现原理">React-router 路由的实现原理？</h4>

<h4 id="说说-react-native-weex-框架的实现原理">说说 React Native，Weex 框架的实现原理？</h4>

<h4 id="受控组件-controlled-component-与非受控组件-uncontrolled-component-的区别">受控组件（Controlled Component）与非受控组件（Uncontrolled Component）的区别</h4>

<h4 id="react-为什么自己定义一套事件体系呢-与浏览器原生事件体系有什么关系">React 为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？</h4>

<h4 id="什么是-hoc-higher-order-component-适用于什么场景">什么是 HoC（Higher-Order Component）？适用于什么场景？</h4>

<p>高阶组件就是一个 React 组件包裹着另外一个 React 组件</p>

<h4 id="redux-是如何做到可预测呢">Redux 是如何做到可预测呢？</h4>

<h4 id="redux-将-react-组件划分为哪两种">Redux 将 React 组件划分为哪两种？</h4>

<h4 id="redux-是如何将-state-注入到-react-组件上的">Redux 是如何将 state 注入到 React 组件上的？</h4>

<h4 id="请描述一次完整的-redux-数据流">请描述一次完整的 Redux 数据流</h4>

<h4 id="react-的批量更新机制-batchupdates">React 的批量更新机制 BatchUpdates？</h4>

<h4 id="react-与-vue-各自的组件更新进行对比-它们有哪些区别">React 与 Vue，各自的组件更新进行对比，它们有哪些区别？</h4>

<h4 id="设计模式-知道什么是-singleton-factory-strategy-decrator-么">设计模式 知道什么是 singleton, factory, strategy, decrator 么？</h4>

<h4 id="列举-ie-与其他浏览器不一样的特性">列举 IE 与其他浏览器不一样的特性？</h4>

<p>事件不同之处：</p>

<p>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性</p>

<p>获取字符代码、如果按键代表一个字符（shift、ctrl、alt 除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性</p>

<p>阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault(); 方法</p>

<p>停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation();</p>

<h4 id="99-的网站都需要被重构是那本书上写的">99% 的网站都需要被重构是那本书上写的？</h4>

<p>网站重构：应用 web 标准进行设计（第 2 版）</p>

<p>BTW：这都是什么神仙问题</p>

<h4 id="部分地区用户反应网站很卡-请问有哪些可能性的原因-以及解决方法">部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？</h4>

<h4 id="从打开-app-到刷新出内容-整个过程中都发生了什么-如果感觉慢-怎么定位问题-怎么解决">从打开 app 到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决？</h4>

<h4 id="第一次访问页面中时弹出引导-用户关闭引导-之后再次进入页面时不希望出现引导-如何实现">第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？</h4>

<p>使用 <code>localStorage</code> 处理实现逻辑</p>

<h4 id="你怎么看待-web-app-hybrid-app-native-app">你怎么看待 Web App 、hybrid App、Native App？</h4>

<h4 id="你移动端前端开发的理解-和-web-前端开发的主要区别是什么">你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）</h4>

<h4 id="如何设计突发大规模并发架构">如何设计突发大规模并发架构？</h4>

<h4 id="知道什么是-seo-并且怎么优化么-知道各种-meta-data-的含义么">知道什么是 SEO 并且怎么优化么? 知道各种 meta data 的含义么?</h4>

<h4 id="你认为怎样才是全端工程师-full-stack-developer">你认为怎样才是全端工程师（Full Stack developer）？</h4>

<h4 id="你有自己的技术博客吗-用了哪些技术">你有自己的技术博客吗，用了哪些技术？</h4>

<h4 id="对前端安全有什么看法">对前端安全有什么看法？</h4>

<h4 id="是否了解-web-注入攻击-说下原理-最常见的两种攻击-xss-和-csrf-了解到什么程度">是否了解 Web 注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</h4>

<p>具体可以参考 <a href="https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1" title="浅说 XSS 和 CSRF" target="_blank">传送门 1</a> <a href="https://segmentfault.com/a/1190000007660669" title="XSS 和 CSRF 两种跨站攻击" target="_blank">传送门 2</a></p>

<h4 id="项目中遇到国哪些印象深刻的技术难题-具体是什么问题-怎么解决">项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？</h4>

<h4 id="最近在学什么东西">最近在学什么东西？</h4>

<h4 id="如何管理前端团队">如何管理前端团队?</h4>

<h4 id="最近在学什么-能谈谈你未来-3-5-年给自己的规划吗">最近在学什么？能谈谈你未来 3，5 年给自己的规划吗？</h4>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2019</span>
            
                <span><a href="https://war408705279.github.io">Zhazha</a></span>
            
            <span><a href="https://github.com/war408705279/" target="_blank" rel="noopener">404 Not Found</a></span>
            <span> <a href="https://war408705279.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    
</footer>

            
        </div>

        





<script type="text/javascript" src="https://war408705279.github.io/js/bundle.f65a6fe80656eb86fce3f1228faa2ac0bf43b28d21eb91975f036839ed92dfd126cabb91223501623641f4ea67ac5d03882d0b8c744da38c637a1fdf8e9016c6.js" integrity="sha512-9lpv6AZW64b84/Eij6oqwL9Dso0h65GXXwNoOe2S39EmyruRIjUBYjZB9OpnrF0DiC0LjHRNo4xjeh/fjpAWxg=="></script>



    </body>
</html>
