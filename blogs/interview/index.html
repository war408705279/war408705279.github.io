<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Zhazha ">
<meta name="description" content="前端 CSS 面试题积累 CSS 的盒子模型 有两种盒子模型
 IE 盒子模型：content 部分包含了 border 和 padding 标准 W3C 盒子模型：包含内容（content）、填充（padding）、边界（margin）、边框（border）  CSS 选择符  id 选择器（#id） 类选择器（.myclassname） 标签选择器（div，h1，p） 相邻选择器（h1&#43;p） 子选择器（ul &amp;gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel = &amp;ldquo;external&amp;rdquo;]） 伪类选择器（a:hover, li:nth-child） 可继承的样式：font-size、font-family、color 等 不可继承的样式：border、padding、margin、width、height 等 优先级就近原则，同权重情况下样式定义最近者为准 优先级为：!important &amp;gt; id 选择器 &amp;gt; class 选择器 &amp;gt; 标签选择器  nth-child 和 nth-of-type 之间的差异 nth-child：按照个数来计算
看如下的例子
&amp;lt;style&amp;gt; p:nth-child(2), p:nth-child(7){ color:red; } &amp;lt;/style&amp;gt; &amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;这是段落&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;这是段落&amp;lt;/p&amp;gt; &amp;lt;span&amp;gt;这是 span&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;这是 span&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;这是 span&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;这是段落&amp;lt;/p&amp;gt; 效果如下所示"/>
<meta name="keywords" content="HTML5, Javascript, css, front-end, blog"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://example.com/blogs/interview/" />


    <title>
        
            前端面试题 :: rm -rf *  — Welcome to my blog
        
    </title>



<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro" rel="stylesheet" type="text/css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://example.com/scss/main.min.099699ab246bf26f50616f7c9f00c79d46110459d1bd727b2d07d6fc09ece082.css">



<link rel="apple-touch-icon" sizes="180x180" href="https://example.com/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.com/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.com/favicon-16x16.png">
<link rel="manifest" href="https://example.com/site.webmanifest">
<link rel="mask-icon" href="https://example.com/safari-pinned-tab.svg" color="">
<link rel="shortcut icon" href="https://example.com/favicon.ico">
<link rel="shortcut icon" href="https://github.githubassets.com/favicon.ico">

<meta itemprop="name" content="前端面试题">
<meta itemprop="description" content="前端 CSS 面试题积累 CSS 的盒子模型 有两种盒子模型
 IE 盒子模型：content 部分包含了 border 和 padding 标准 W3C 盒子模型：包含内容（content）、填充（padding）、边界（margin）、边框（border）  CSS 选择符  id 选择器（#id） 类选择器（.myclassname） 标签选择器（div，h1，p） 相邻选择器（h1&#43;p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel = &ldquo;external&rdquo;]） 伪类选择器（a:hover, li:nth-child） 可继承的样式：font-size、font-family、color 等 不可继承的样式：border、padding、margin、width、height 等 优先级就近原则，同权重情况下样式定义最近者为准 优先级为：!important &gt; id 选择器 &gt; class 选择器 &gt; 标签选择器  nth-child 和 nth-of-type 之间的差异 nth-child：按照个数来计算
看如下的例子
&lt;style&gt; p:nth-child(2), p:nth-child(7){ color:red; } &lt;/style&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;span&gt;这是 span&lt;/span&gt; &lt;span&gt;这是 span&lt;/span&gt; &lt;span&gt;这是 span&lt;/span&gt; &lt;p&gt;这是段落&lt;/p&gt; 效果如下所示">


<meta itemprop="datePublished" content="2019-03-09T00:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2019-03-09T00:00:00&#43;08:00" />
<meta itemprop="wordCount" content="1093">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com"/>

<meta name="twitter:title" content="前端面试题"/>
<meta name="twitter:description" content="前端 CSS 面试题积累 CSS 的盒子模型 有两种盒子模型
 IE 盒子模型：content 部分包含了 border 和 padding 标准 W3C 盒子模型：包含内容（content）、填充（padding）、边界（margin）、边框（border）  CSS 选择符  id 选择器（#id） 类选择器（.myclassname） 标签选择器（div，h1，p） 相邻选择器（h1&#43;p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel = &ldquo;external&rdquo;]） 伪类选择器（a:hover, li:nth-child） 可继承的样式：font-size、font-family、color 等 不可继承的样式：border、padding、margin、width、height 等 优先级就近原则，同权重情况下样式定义最近者为准 优先级为：!important &gt; id 选择器 &gt; class 选择器 &gt; 标签选择器  nth-child 和 nth-of-type 之间的差异 nth-child：按照个数来计算
看如下的例子
&lt;style&gt; p:nth-child(2), p:nth-child(7){ color:red; } &lt;/style&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;span&gt;这是 span&lt;/span&gt; &lt;span&gt;这是 span&lt;/span&gt; &lt;span&gt;这是 span&lt;/span&gt; &lt;p&gt;这是段落&lt;/p&gt; 效果如下所示"/>



<meta property="article:published_time" content="2019-03-09 00:00:00 &#43;0800 CST" />









    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://example.com/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ rm -rf *</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://example.com/blogs/">博客</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://example.com/blogs/interview/">前端面试题</a></h2>

            

            <div class="post-content">
                

<h3 id="前端-css-面试题积累">前端 CSS 面试题积累</h3>

<h4 id="css-的盒子模型">CSS 的盒子模型</h4>

<p>有两种盒子模型</p>

<ul>
<li>IE 盒子模型：content 部分包含了 border 和 padding</li>
<li>标准 W3C 盒子模型：包含内容（content）、填充（padding）、边界（margin）、边框（border）</li>
</ul>

<h4 id="css-选择符">CSS 选择符</h4>

<ul>
<li>id 选择器（#id）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div，h1，p）</li>
<li>相邻选择器（h1+p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（*）</li>
<li>属性选择器（a[rel = &ldquo;external&rdquo;]）</li>
<li>伪类选择器（a:hover, li:nth-child）</li>
<li>可继承的样式：font-size、font-family、color 等</li>
<li>不可继承的样式：border、padding、margin、width、height 等</li>
<li>优先级就近原则，同权重情况下样式定义最近者为准</li>
<li>优先级为：!important &gt; id 选择器 &gt; class 选择器 &gt; 标签选择器</li>
</ul>

<h4 id="nth-child-和-nth-of-type-之间的差异">nth-child 和 nth-of-type 之间的差异</h4>

<p>nth-child：按照个数来计算</p>

<p>看如下的例子</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
  <span class="nt">p</span><span class="p">:</span><span class="nd">nth-child</span><span class="o">(</span><span class="nt">2</span><span class="o">),</span> <span class="nt">p</span><span class="p">:</span><span class="nd">nth-child</span><span class="o">(</span><span class="nt">7</span><span class="o">)</span><span class="p">{</span>
    <span class="k">color</span><span class="p">:</span><span class="kc">red</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>标题<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>这是段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>这是段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>这是 span<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>这是 span<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>这是 span<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>这是段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span></code></pre></div>
<p>效果如下所示</p>

<p><img src="https://example.com/images/blogs/nth-child-effect.png" alt="nth-child 样式效果" title="nth-child 样式效果" /></p>

<p>可以看出尽管我们在 :nth-child 前面加了 p 标签，nth-child 还是是根据元素的个数来计算的</p>

<p>nth-of-type：按照类型来计算，如果是 class，碰到不同类型的，单独一类，符合条件的选中</p>

<p>看如下的例子</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
  <span class="nt">p</span><span class="p">:</span><span class="nd">nth-of-type</span><span class="o">(</span><span class="nt">1</span><span class="o">),</span> <span class="nt">p</span><span class="p">:</span><span class="nd">nth-of-type</span><span class="o">(</span><span class="nt">3</span><span class="o">)</span><span class="p">{</span>
    <span class="k">color</span><span class="p">:</span><span class="kc">red</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>标题<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>这是段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>这是段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>这是 span<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>这是 span<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>这是 span<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>这是段落<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span></code></pre></div>
<p>效果如下所示</p>

<p><img src="https://example.com/images/blogs/nth-of-type-effect.png" alt="nth-of-type 样式效果" title="nth-of-type 样式效果" /></p>

<h3 id="前端-html-面试题积累">前端 HTML 面试题积累</h3>

<h4 id="语义化的-html">语义化的 HTML</h4>

<ul>
<li>直观的认识标签对于搜索引擎的抓取有好处，用正确的标签做正确的事情</li>
<li>HTML 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析</li>
<li>在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO</li>
<li>使阅读源代码的人更容易将网站分块，便于阅读维护理解</li>
</ul>

<h4 id="doctype-html-标签">&lt;!DOCTYPE html&gt; 标签</h4>

<p>H5 不基于 SGML，因此不需要对 DTD（document type definition）进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.0 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型</p>

<h3 id="前端-js-面试题积累">前端 JS 面试题积累</h3>

<h4 id="js-获取-url-中的-query-参数">JS 获取 URL 中的 Query 参数</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">getQueryString</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">reg</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="s1">&#39;(^|&amp;)&#39;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;=([^&amp;]*)(&amp;|$)&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">routerStore</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">search</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">match</span><span class="p">(</span><span class="nx">reg</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">unescape</span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
 <span class="p">}</span>
 
 <span class="c1">// 调用的时候传递 query 参数的 key 值进去
</span><span class="c1"></span> <span class="c1">// 例如需要获取 url 中 id 对应的值
</span><span class="c1"></span> <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">getQueryString</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
</code></pre></div>
<h4 id="call-和-apply-的异同">call() 和 apply() 的异同</h4>

<p>call 和 apply 的基本作用都是改变对象执行的上下文</p>

<p>call 的基本使用</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span> <span class="p">[,</span> <span class="nx">arg1</span> <span class="p">[,</span> <span class="nx">arg2</span><span class="p">[,</span> <span class="p">[,</span> <span class="nx">argN</span><span class="p">]]]]])</span>
</code></pre></div>
<p>说明</p>

<ul>
<li>调用 call 的对象必须是一个函数 function</li>
<li>call 的第一个参数将会是 function 改变上下文后指向的对象，如果不传，将会默认是全局对象，在浏览器中就是 window</li>
<li>第二个参数开始可以接收任意个参数，这些参数将会作为 function 的参数传入 function</li>
<li>调用 call 的方法会立即执行</li>
</ul>

<p>apply 的基本使用</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span> <span class="p">[,</span> <span class="nx">argArray</span><span class="p">])</span>
</code></pre></div>
<p>说明</p>

<ul>
<li>与 call 方法的使用基本一致，但是只接收两个参数，其中第二个参数必须是一个数组或者类数组</li>
</ul>

<p>两个方法的相同点</p>

<p>都能够改变方法的执行上下文（执行环境），将一个对象的方法交给另一个对象来执行，并且是立即执行</p>

<p>两个方法的不同点</p>

<p>call 方法从第二个参数开始可以接收任意个参数，每个参数会映射到相应位置的 function 的参数上，可以通过参数名调用，但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 function 对应的第一个参数上，之后参数都为空</p>

<p>apply 方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入 function 中，并且会被映射到 function 对应的参数上</p>

<p>两个参数如何选择</p>

<p>根据要传入的参数进行选择，不需要传参或者只有一个参数时，用 call。当要传入多个对象时，用 apply</p>

<h4 id="数组和类数组">数组和类数组</h4>

<p>数组的特征</p>

<ul>
<li>可以通过角标调用，如 array[0]</li>
<li>具有长度属性 length</li>
<li>可以通过 for 循环和 forEach 方法进行遍历</li>
</ul>

<p>类数组具备的特征应该与数组基本相同，例如下面这个对象就是一个类数组</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">arrayLike</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="o">:</span> <span class="s1">&#39;item1&#39;</span><span class="p">,</span>
  <span class="mi">1</span><span class="o">:</span> <span class="s1">&#39;item2&#39;</span><span class="p">,</span>
  <span class="mi">2</span><span class="o">:</span> <span class="s1">&#39;item3&#39;</span><span class="p">,</span>
  <span class="nx">length</span><span class="o">:</span> <span class="mi">3</span>
<span class="p">}</span>
</code></pre></div>
<p>类数组 arrayLike 可以通过角标进行调用，具有 length 属性，同时也可以通过 for 循环进行遍历
那么问题来了，<strong>如何让类数组使用 forEach</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// dom 树其实就是一个类数组结构
</span><span class="c1"></span>
<span class="p">[].</span><span class="nx">forEach</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&#34;div&#34;</span><span class="p">),</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>

<span class="p">[].</span><span class="nx">forEach</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&#34;div&#34;</span><span class="p">),</span> <span class="p">[(</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">)])</span>
</code></pre></div>
<h4 id="数组方法">数组方法</h4>

<p>push(): 尾部添加</p>

<p>pop(): 尾部删除</p>

<p>unshift(): 头部添加</p>

<p>shift(): 头部删除</p>

<h4 id="添加-删除-替换-插入某个节点的方法">添加、删除、替换、插入某个节点的方法</h4>

<p>对 dom 树节点进行操作</p>

<p>添加: obj.appendChild</p>

<p>删除: obj.removeChild</p>

<p>替换: obj.replaceChild</p>

<p>插入: obj.innersetBefore</p>

<h4 id="同源策略">同源策略</h4>

<p>JS 同源策略：一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合</p>

<h4 id="instanceof">instanceof</h4>

<p>instanceof 用于判断一个变量是否属于某个对象的实例</p>

<p>instanceof 运算符可以用来判断某个构造函数的 prototype 属性是否存在于另外一个要检测对象的原型链上</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">a</span> <span class="k">instanceof</span> <span class="nx">b</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
</code></pre></div>
<p>实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">);</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">)</span> <span class="c1">// true
</span></code></pre></div>
<h4 id="js-闭包">JS 闭包</h4>

<p>定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包</p>

<p>表现形式：使函数外部能够调用函数内部定义的变量</p>

<p>实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 全局作用域 标记为 flag1
</span><span class="c1"></span>
<span class="kd">function</span> <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 函数全局作用域 标记为 flag2
</span><span class="c1"></span>  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 函数的内部作用域
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">add</span><span class="p">()</span>
<span class="nx">s</span><span class="p">();</span> <span class="c1">// 输出 1
</span><span class="c1"></span><span class="nx">s</span><span class="p">();</span> <span class="c1">// 输出 2
</span></code></pre></div>
<p>根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到 window 的变量，没有就返回 undefined。这里明显 count 是函数内部的 flag2 的那个 count</p>

<p>使用闭包需要注意的点</p>

<ul>
<li>滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除</li>
<li>会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值</li>
</ul>

<h4 id="变量声明提升和函数声明提升">变量声明提升和函数声明提升</h4>

<p>变量声明提升</p>

<h5 id="变量定义">变量定义</h5>

<p>可以使用 var 定义变量，变量如果没有赋值，那变量的初始值为 undefined</p>

<h5 id="变量作用域">变量作用域</h5>

<p>变量作用域指变量起作用的范围。变量分为*全局变量*和*局部变量*。全局变量在全局都拥有定义；而局部变量只能在函数内有效</p>

<p>*在函数体内，同名的局部变量或者参数的优先级会高于全局变量*。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖</p>

<p>所有不使用 var 定义的变量都视为全局变量</p>

<h5 id="函数作用域和声明提前">函数作用域和声明提前</h5>

<p>JavaScript 的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说变量在声明之前已经可用，所有这特性称为声明提前（hoisting），即 JavaScript 函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置</p>

<p>*注释*：声明提前是在 JavaScript 引擎的预编译时进行，是在代码开始运行之前</p>

<p>如下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s1">&#39;global&#39;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s1">&#39;local&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 第一次输出 undefined，第二次输出 local
</span></code></pre></div>
<h5 id="函数声明提升">函数声明提升</h5>

<p>*注*：只有函数声明式语法才会出现函数提升</p>

<p>函数的两种创建方式</p>

<p>（1）函数声明语法</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 函数声明语法
</span><span class="c1"></span><span class="nx">f</span><span class="p">(</span><span class="s1">&#39;superman&#39;</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 结果会输出 superman
</span></code></pre></div>
<p>（2）函数表达式语法</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 函数表达式语法
</span><span class="c1"></span><span class="nx">f</span><span class="p">(</span><span class="s1">&#39;superman&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">f</span><span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 上述代码会报错
</span></code></pre></div>
<p>函数声明提升</p>

<p>函数声明提升，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面</p>

<p><em>值得注意的是，函数声明提升在变量声明提升的前面</em></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getName</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">getName</span><span class="p">();</span>
</code></pre></div>
<p>可能会有人觉得最后输出的结果是 1。让我们来分析一下，这个例子涉及到了变量声明提升和函数声明提升。正如前面说到的函数声明提升，函数声明 <code>function getName() {...}</code> 的声明会被提前到顶部。而函数表达式 <code>var getName = function() {...}</code> 则表现出变量声明提升。因此在这种情况下，getName 也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。因此上面的函数可以转换成下面的样子</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">getName</span><span class="p">;</span> <span class="c1">// 变量声明提升
</span><span class="c1"></span>
<span class="kd">function</span> <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 函数声明提升到顶部
</span><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 变量赋值依然保留在原来的位置
</span><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">getName</span><span class="p">();</span> <span class="c1">// 最终输出：2
</span></code></pre></div>
<h3 id="前后端请求相关面试题积累">前后端请求相关面试题积累</h3>

<h4 id="http-状态码">http 状态码</h4>

<p>100-199：用于指定客户端相应的某些动作，服务器接收到请求，需要请求者继续执行操作</p>

<p>200-299：用于表示请求成功</p>

<p>300-399：用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。重定向，需要进一步的操作以完成请求</p>

<p>400-499：用于指出客户端的错误，请求包含语法 错误或无法完成请求。400 - 客户端请求语法有错误，服务器无法理解；401 - 当前请求需要用户验证；403 - 服务器理解请求客户端的请求，但是拒绝执行此请求；404 - 服务器无法根据客户端的请求找到资源（网页）</p>

<p>500-599：服务器端错误。500 - 服务器内部错误，无法完成请求；501 - 服务器不支持请求的功能；502 - 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求；503 - 服务不可用</p>

<h4 id="ajax-中-get-和-post-方法的区别">Ajax 中 GET 和 POST 方法的区别</h4>

<h5 id="get-和-post-都是向服务器发送的一种请求-只是发送机制不同">GET 和 POST 都是向服务器发送的一种请求，只是发送机制不同</h5>

<ul>
<li><p>GET 请求会将参数跟在 URL 后进行传递，而 POST 请求则是作为 HTTP 消息的实体内容发送给 WEB 服务器。当然在 Ajax 请求中，这种区别对用户是不可见的</p></li>

<li><p>首先是 GET 方式提交的数据最多只能是 1024 字节，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。*这个限制是特定的浏览器及服务器对它的限制*。IE 对 URL 长度的限制是 2083 字节（2K+35）。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度</p></li>

<li><p>GET 方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET 方式会带来严重的安全问题。而 POST 方式相对来说就可以避免这些问题</p></li>
</ul>

<h5 id="get-请求和-post-请求在服务器端的区别">GET 请求和 POST 请求在服务器端的区别</h5>

<ul>
<li><p>在客户端使用 GET 请求时，服务器端使用 Request.QueryString 来获取参数，而客户端使用 POST 请求时，服务器端使用 Request.Form 来获取参数</p></li>

<li><p>HTTP 标准包含这两种方法是为了达到不同的目的。POST 用于创建资源，资源的内容会被编入 HTTP 请示的内容中。例如，处理订货表单、在数据库中加入新数据行等
当请求无副作用时（如进行搜索），便可使用 GET 方法；当请求有副作用时（如添加数据行），则用 POST 方法。一个比较实际的问题是：GET 方法可能会产生很长的 URL，或许会超过某些浏览器与服务器对 URL 长度的限制</p></li>
</ul>

<h5 id="若符合下列任一情况-则用-post-方法">若符合下列任一情况，则用 POST 方法</h5>

<ul>
<li>请求的结果有持续性的副作用，例如，数据库内添加新的数据行</li>
<li>若使用 GET 方法，则表单上收集的数据可能让 URL 过长</li>
<li>要传送的数据不是采用 7 位的 ASCII 编码</li>
</ul>

<h5 id="若符合下列任一情况-则用-get-方法">若符合下列任一情况，则用 GET 方法</h5>

<ul>
<li>请求是为了查找资源，HTML 表单数据仅用来帮助搜索</li>
<li>请求结果无持续性的副作用</li>
<li>收集的数据及 HTML 表单内的输入字段名称的总长不超过 1024个 字符</li>
</ul>

<h4 id="http-类型">HTTP 类型</h4>

<p>HTTP 协议类型有 8 种，分别是</p>

<ul>
<li><p>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送 * 的请求来测试服务器的功能性</p></li>

<li><p>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息</p></li>

<li><p>GET：向特定的资源发出请求</p></li>

<li><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的创建和 / 或已有资源的修改</p></li>

<li><p>PUT：向指定资源位置上传其最新内容</p></li>

<li><p>DELETE：请求服务器删除 Request-URI 所标识的资源</p></li>

<li><p>TRACE：回显服务器收到的请求，主要用于测试或诊断</p></li>

<li><p>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</p></li>
</ul>

<h4 id="put-和-post-的区别">PUT 和 POST 的区别</h4>

<p>PUT 和 POST 的技术实现上应该是没有很大区别的。但在于协议上语义是很大区别</p>

<p>PUT 的方法就是其字面表意，将 client 的资源放在请求 URI 上。对于服务器到底是*创建*还是*更新*，由服务器返回的 HTTP Code 来区别。如果用 PUT 来达到更改资源，需要 client 提交资源全部信息，如果只有部分信息，不应该使用 PUT（因为服务器使用 client 提交的对象整体替换服务器的资源）</p>

<p>基本上不能方便的归纳为*增删改*之类的行为，都可以使用 POST 方法。另外可以使用 POST 去实现<em>部分更新资源</em></p>

<h3 id="前端其他相关面试题积累">前端其他相关面试题积累</h3>

<h4 id="浏览器内核">浏览器内核</h4>

<ul>
<li>IE 浏览器：Trident（IE 内核）</li>
<li>火狐浏览器：Gecko，特点是代码完全公开</li>
<li>Opera 浏览器：前期采用 Presto 内核，现已改用 Google Chrome 的 Blink 内核</li>
<li>Safari 浏览器：Webkit 内核，Webkit 内核是 Chrome 内核的原型</li>
<li>Chrome 浏览器：采用 Blink 内核，是 Google 和 Opera Software 开发的浏览器排版引擎</li>
</ul>

<h4 id="ie6-bug-的解决方法">IE6 BUG 的解决方法</h4>

<ul>
<li>由 float 引起的双边距 BUG，使用 display 解决</li>
<li>由 float 引起的 3 像素问题，使用 display: inline -3px</li>
<li>超链接 hover 点击后失效，使用正确的书写顺序 link visited hover active</li>
<li>IE z-index 问题，给父级添加 position: relative</li>
<li>png 透明，使用 js 代码进行修改</li>
<li>min-height 最小高度，使用 !important 解决</li>
<li>select 在 IE6 下遮盖，使用 iframe 嵌套</li>
<li>为什么没有办法定义 1px 左右的宽度容器，是由 IE6 默认的行高造成的，使用样式 overflow: hidden, zoom: 0.08; line-height: 1px; 解决</li>
</ul>

<h4 id="react-的特点">React 的特点</h4>

<ul>
<li>声明式设计</li>
<li>高效：通过对 DOM 的模拟，最大限度的减少与 DOM 的交互</li>
<li>灵活：可以与已知的框架或库很好的配合</li>
<li>JSX：是 js 语法的扩展，不一定使用，但建议用</li>
<li>组件：构建组件，使代码更容易得到复用，能够很好地应用在大项目的开发中</li>
<li>单向响应的数据流：React 实现了单向响应的数据流，从而减少了重复代码，这也是解释了它为什么比传统数据绑定更简单</li>
</ul>

<h4 id="vue-的特性">Vue 的特性</h4>

<ul>
<li>轻量级框架</li>
<li>MVVM 框架</li>
<li>数据驱动</li>
<li>组件化</li>
<li>双向数据绑定</li>
<li>指令</li>
<li>插件化</li>
<li>轻量、简洁、高效、快速、模块友好</li>
</ul>

<h4 id="bootstrap-的特点">Bootstrap 的特点</h4>

<ul>
<li>跨设备、跨浏览器，可以兼容所有现在浏览器，包括比较诟病的 IE7、8</li>
<li>响应式布局，不但支持 PC 端的各种分辨率，还支持移动端 pad，手机等屏幕的响应式切换显示</li>
<li>提供全面的组件，Bootstrap 提供了实用性很强的组件，包括：导航、标签、工具条、按钮等</li>
<li>内置 jquery 插件</li>
<li>支持 HTML5、CSS3</li>
<li>支持 less 动态样式</li>
</ul>

<h4 id="node">Node</h4>

<p>Node 的使用场景：高并发、聊天、实时消息推送</p>

<h4 id="性能优化的方法">性能优化的方法</h4>

<ul>
<li>减少 http 请求次数：CSS、JS 等源码压缩，图片大小控制合适，data 缓存，图片服务器</li>
<li>前端模版 JS + 数据，较少由于 HTML 标签导致的带宽浪费，前端用变量保存 ajax 请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 JS 性能</li>
<li>当需要设置的样式很多时设置 className，而不是直接操作 style</li>
<li>少用全局变量、缓存 DOM 节点查找的结果，减少 IO 读取操作</li>
<li>避免使用 CSS Expression（css 表达式），又称动态属性</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</li>
<li>避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示效率慢</li>
</ul>

<h4 id="前端优化">前端优化</h4>

<p>在不影响功能和体验的情况下</p>

<p>能在浏览器执行的不要在服务器执行</p>

<p>能在缓存服务器上直接返回的不要到应用服务器</p>

<p>程序能直接取得结果的不要到外部取得</p>

<p>本机内能取得的数据不要到远程取</p>

<p>内存能取到的不要到磁盘取</p>

<p>缓存中有的数据不要去数据库查询</p>

<h4 id="一个页面从输入-url-到页面加载显示完成-这个过程中都发生了什么">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么</h4>

<ul>
<li>查找浏览器缓存</li>
<li>DNS 解析、查找该域名对应的 IP 地址、重定向（301）、发出第二个 GET 请求</li>
<li>进行 HTTP 协议会话</li>
<li>客户端发送报头（请求报头）</li>
<li>文档开始下载</li>
<li>文档树建立，根据标记请求所需指定 MIME 类型的文件</li>
<li>文件显示</li>
</ul>

<p>浏览器这边做的工作大致分为以下几步</p>

<ul>
<li>加载：根据请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）</li>
<li>解析：对加载到的资源（HTML、JS、CSS 等）进行语法解析，建议相应的内部数据结构（比如 HTML 的 DOM 树，JS 的（对象）属性表，CSS 的样式规则等等）</li>
</ul>

<h4 id="vue-和-angularjs-的异同">Vue 和 AngularJS 的异同</h4>

<p>相同点</p>

<ul>
<li>都支持指令：内置指令和自定义指令</li>
<li>都支持过滤器：内置过滤器和自定义过滤器</li>
<li>都支持双向数据绑定</li>
<li>都不支持低端浏览器</li>
</ul>

<p>不同点</p>

<ul>
<li>AngularJS 的学习成本高</li>
<li>在性能上，AngularJS 依赖对数据做脏检查，所以 Watcher 越多越慢</li>
</ul>

<h4 id="vue-和-react-的异同">Vue 和 React 的异同</h4>

<p>相同点</p>

<ul>
<li>React 采用特殊的 JSX 语法，Vue 在组件开发中也推崇编写 .vue 特殊文件格式，对文件内容有一定的约定，两者都需要编译后使用</li>
<li>二者的中心思想都是一切都是组件，组件实例之间可以嵌套</li>
<li>都提供合理的钩子函数，可以让开发者定制化地去处理需求</li>
<li>都不内置 Ajax、Route 等功能到核心包，而是以插件的方式加载</li>
<li>组件开发中都支持 mixins 的特性</li>
</ul>

<p>不同点</p>

<ul>
<li>React 依赖 virtual DOM，而 Vue 使用的是 DOM 模版，React 采用的 virtual DOM 会对渲染出来的结果做脏检查</li>
<li>Vue 在模板中提供了指令，过滤器等，可以非常方便、快捷的操作 DOM</li>
</ul>

<h4 id="vue-生命周期">Vue 生命周期</h4>

<p>如下图所示</p>

<p><img src="https://example.com/images/blogs/vue-lifecycle.png" alt="Vue 生命周期" title="Vue 生命周期" /></p>

<h4 id="react-生命周期">React 生命周期</h4>

<h5 id="实例化">实例化</h5>

<p>首次实例化</p>

<ul>
<li>getDefaultProps</li>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>

<p>实例化完成后的更新</p>

<ul>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>

<h5 id="存在期">存在期</h5>

<p>组件已存在时的状态改变</p>

<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>

<p>销毁 &amp; 清理期</p>

<ul>
<li>componentWillUnmount</li>
</ul>

<h5 id="说明">说明</h5>

<p>生命周期共提供了 10 个不同的 API</p>

<ul>
<li>getDefaultProps</li>
</ul>

<p>作用于组件类，只调用一次，返回对象用于设置默认的 props，对于引用值，会在实例中共享</p>

<ul>
<li>getInitialState</li>
</ul>

<p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的 state，此时可以访问 this.props</p>

<ul>
<li>componentWillMount</li>
</ul>

<p>在完成首次渲染之前调用，此时仍可以修改组件的 state</p>

<ul>
<li>render</li>
</ul>

<p>必选的方法，创建虚拟 DOM，该方法具有特殊的规则</p>

<ul>
<li>只能通过 this.props 和 this.state 访问数据</li>
<li>可以返回 null、false 或任何 React 组件</li>
<li>只能出现一个顶级组件（不能返回数组）</li>
<li>不能改变组件的状态</li>

<li><p>不能修改 DOM 的输出</p></li>

<li><p>componentDidMount</p></li>
</ul>

<p>真实的 DOM 被渲染出来后调用，在该方法中可通过 this.getDOMNode() 访问到真实的 DOM 元素。此时已可以使用其他类库来操作这个 DOM</p>

<p>在服务端中，该方法不会被调用</p>

<ul>
<li>componentWillReceiveProps</li>
</ul>

<p>组件接收到新的 props 时调用，并将其作为参数 nextProps 使用，此时可以更改组件 props 及 state</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">componentWillReceiveProps</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">nextProps</span><span class="p">.</span><span class="nx">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="nx">bool</span><span class="o">:</span> <span class="kc">true</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>shouldComponentUpdate</li>
</ul>

<p>组件是否应当渲染新的 props 或 state，返回 false 表示跳过后续的生命周期方法，通常不需要使用以避免出现 bug。在出现应用的瓶颈时，可通过该方法进行适当的优化</p>

<p>在首次渲染期间或者调用了 forceUpdate 方法后，该方法不会被调用</p>

<ul>
<li>componentWillUpdate</li>
</ul>

<p>接收到新的 props 或者 state 后，进行渲染之前调用，此时不允许更新 props 或 state</p>

<ul>
<li>componentDidUpdate</li>
</ul>

<p>完成渲染新的 props 或者 state 后调用，此时可以访问到新的 DOM 元素</p>

<ul>
<li>componentWillUnmount</li>
</ul>

<p>组件被移除之前被调用，可以用于做一些清理工作，在 componentDidMount 方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2019</span>
            
                <span><a href="https://example.com">Zhazha</a></span>
            
            <span><a href="https://github.com/war408705279/" target="_blank" rel="noopener">404 Not Found</a></span>
            <span> <a href="https://example.com/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    
</footer>

            
        </div>

        





<script type="text/javascript" src="https://example.com/js/bundle.f65a6fe80656eb86fce3f1228faa2ac0bf43b28d21eb91975f036839ed92dfd126cabb91223501623641f4ea67ac5d03882d0b8c744da38c637a1fdf8e9016c6.js" integrity="sha512-9lpv6AZW64b84/Eij6oqwL9Dso0h65GXXwNoOe2S39EmyruRIjUBYjZB9OpnrF0DiC0LjHRNo4xjeh/fjpAWxg=="></script>



    </body>
</html>
