<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Zhazha ">
<meta name="description" content="事件循环 首先说一下事件循环
浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的
理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要
事件循环的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环
引擎的一般算法：
 当有任务时：从最先进入的任务开始执行 休眠直到出现任务，然后转到第 1 步  一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的宏任务队列
宏任务 &amp;amp;&amp;amp; 微任务 除了上述所讲的宏任务外，还有微任务
微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的幕后，因为它是 promise 处理的另一种形式
还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行
每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作
看下面的例子
setTimeout(() =&amp;gt; alert(&amp;#39;timeout&amp;#39;)); Promise.resolve().then(() =&amp;gt; alert(&amp;#39;promise&amp;#39;)); alert(&amp;#39;code&amp;#39;);  上面代码的执行顺序为：
 code 首先显示，因为它是常规的同步调用 promise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行 timeout 最后显示，因为它是一个宏任务  微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成
比较常见的面试题 下面这段代码的输出顺序是什么
setTimeout(function () { console.log(&amp;#39;1&amp;#39;) new Promise((resolve) =&amp;gt; { console.log(&amp;#39;2&amp;#39;) resolve() })."/>
<meta name="keywords" content="HTML5, Javascript, css, front-end, blog"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://war408705279.github.io/blogs/js-macro-micro-task/" />


    <title>
        
            JS 宏任务和微任务 :: 简眸。  — 人生漫长我劝你好生走路
        
    </title>



<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro" rel="stylesheet" type="text/css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://war408705279.github.io/scss/main.min.099699ab246bf26f50616f7c9f00c79d46110459d1bd727b2d07d6fc09ece082.css">



<link rel="apple-touch-icon" sizes="180x180" href="https://war408705279.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://war408705279.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://war408705279.github.io/favicon-16x16.png">
<link rel="manifest" href="https://war408705279.github.io/site.webmanifest">
<link rel="mask-icon" href="https://war408705279.github.io/safari-pinned-tab.svg" color="">
<link rel="shortcut icon" href="https://war408705279.github.io/favicon.ico">
<link rel="shortcut icon" href="https://github.githubassets.com/favicon.ico">

<meta itemprop="name" content="JS 宏任务和微任务">
<meta itemprop="description" content="事件循环 首先说一下事件循环
浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的
理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要
事件循环的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环
引擎的一般算法：
 当有任务时：从最先进入的任务开始执行 休眠直到出现任务，然后转到第 1 步  一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的宏任务队列
宏任务 &amp;&amp; 微任务 除了上述所讲的宏任务外，还有微任务
微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的幕后，因为它是 promise 处理的另一种形式
还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行
每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作
看下面的例子
setTimeout(() =&gt; alert(&#39;timeout&#39;)); Promise.resolve().then(() =&gt; alert(&#39;promise&#39;)); alert(&#39;code&#39;);  上面代码的执行顺序为：
 code 首先显示，因为它是常规的同步调用 promise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行 timeout 最后显示，因为它是一个宏任务  微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成
比较常见的面试题 下面这段代码的输出顺序是什么
setTimeout(function () { console.log(&#39;1&#39;) new Promise((resolve) =&gt; { console.log(&#39;2&#39;) resolve() }).">


<meta itemprop="datePublished" content="2022-07-31T15:02:54&#43;08:00" />
<meta itemprop="dateModified" content="2022-07-31T15:02:54&#43;08:00" />
<meta itemprop="wordCount" content="137">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://war408705279.github.io"/>

<meta name="twitter:title" content="JS 宏任务和微任务"/>
<meta name="twitter:description" content="事件循环 首先说一下事件循环
浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的
理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要
事件循环的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环
引擎的一般算法：
 当有任务时：从最先进入的任务开始执行 休眠直到出现任务，然后转到第 1 步  一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的宏任务队列
宏任务 &amp;&amp; 微任务 除了上述所讲的宏任务外，还有微任务
微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的幕后，因为它是 promise 处理的另一种形式
还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行
每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作
看下面的例子
setTimeout(() =&gt; alert(&#39;timeout&#39;)); Promise.resolve().then(() =&gt; alert(&#39;promise&#39;)); alert(&#39;code&#39;);  上面代码的执行顺序为：
 code 首先显示，因为它是常规的同步调用 promise 第二个出现，因为 then 会通过微任务队列，并在当前代码之后执行 timeout 最后显示，因为它是一个宏任务  微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成
比较常见的面试题 下面这段代码的输出顺序是什么
setTimeout(function () { console.log(&#39;1&#39;) new Promise((resolve) =&gt; { console.log(&#39;2&#39;) resolve() })."/>



<meta property="article:published_time" content="2022-07-31 15:02:54 &#43;0800 CST" />









    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://war408705279.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">简眸。</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://war408705279.github.io/blogs/">博客</a></li><li><a href="https://war408705279.github.io/travel/">游记</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://war408705279.github.io/blogs/js-macro-micro-task/">JS 宏任务和微任务</a></h2>

            

            <div class="post-content">
                

<h3 id="事件循环">事件循环</h3>

<p>首先说一下<code>事件循环</code></p>

<p>浏览器中 <code>JavaScript</code> 的执行流程和 <code>Node.js</code> 中的流程都是基于<code>事件循环</code>的</p>

<p>理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要</p>

<p><code>事件循环</code>的概念非常简单。它是一个在 <code>JavaScript</code> 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环</p>

<p>引擎的一般算法：</p>

<ul>
<li>当有任务时：从最先进入的任务开始执行</li>
<li>休眠直到出现任务，然后转到第 <code>1</code> 步</li>
</ul>

<p>一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的<code>宏任务队列</code></p>

<h3 id="宏任务-微任务">宏任务 &amp;&amp; 微任务</h3>

<p>除了上述所讲的<code>宏任务</code>外，还有<code>微任务</code></p>

<p>微任务仅来自于我们的代码。它们通常是由 <code>promise</code> 创建的：对 <code>.then/catch/finally</code> 处理程序的执行会成为微任务。微任务也被用于 <code>await</code> 的幕后，因为它是 <code>promise</code> 处理的另一种形式</p>

<p>还有一个特殊的函数 <code>queueMicrotask(func)</code>，它对 <code>func</code> 进行排队，以在微任务队列中执行</p>

<p>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作</p>

<p>看下面的例子</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;timeout&#39;</span><span class="p">));</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;promise&#39;</span><span class="p">));</span>

<span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;code&#39;</span><span class="p">);</span>
</code></pre></div>
<p>上面代码的执行顺序为：</p>

<ul>
<li><code>code</code> 首先显示，因为它是常规的同步调用</li>
<li><code>promise</code> 第二个出现，因为 <code>then</code> 会通过微任务队列，并在当前代码之后执行</li>
<li><code>timeout</code> 最后显示，因为它是一个宏任务</li>
</ul>

<p>微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成</p>

<h3 id="比较常见的面试题">比较常见的面试题</h3>

<p>下面这段代码的输出顺序是什么</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
  
  <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>
    <span class="nx">resolve</span><span class="p">()</span>
  <span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;6&#39;</span><span class="p">)</span>
  <span class="nx">resolve</span><span class="p">()</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;7&#39;</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;8&#39;</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">)</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div>
<p>正确的输出顺序为：<code>6 4 8 1 2 3 5 7</code></p>

<p>再看一道题</p>

<p>下面这段代码的输出顺序是什么</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="nx">resolve</span><span class="p">()</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
  <span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>正确的输出顺序为：<code>1 2 3 5 6 4</code></p>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2022</span>
            
                <span><a href="https://war408705279.github.io">Zhazha</a></span>
            
            <span><a href="https://github.com/war408705279/" target="_blank" rel="noopener">404 Not Found</a></span>
            <span> <a href="https://war408705279.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    
</footer>

            
        </div>

        





<script type="text/javascript" src="https://war408705279.github.io/js/bundle.f65a6fe80656eb86fce3f1228faa2ac0bf43b28d21eb91975f036839ed92dfd126cabb91223501623641f4ea67ac5d03882d0b8c744da38c637a1fdf8e9016c6.js" integrity="sha512-9lpv6AZW64b84/Eij6oqwL9Dso0h65GXXwNoOe2S39EmyruRIjUBYjZB9OpnrF0DiC0LjHRNo4xjeh/fjpAWxg=="></script>



<script
  type="text/javascript"
  color="254,81,134"
  pointColor="254,81,134"
  opacity="1"
  count="99"
  zIndex="-1"
  src="https://war408705279.github.io/js/canvas-nest.js"
></script>

    </body>
</html>
