<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Zhazha ">
<meta name="description" content="React Native 中的 component 和 Android 中的 activity、fragment 等一样，存在声明周期，下面先给出 component 的生命周期图
 ##### getDefaultProps  object getDefaultProps()  执行过一次后，被创建的类会有缓存，映射的值会存在 this.props，前提是这个 prop 不是父组件指定的，这个方法在对象被创建之前执行，因此不能在方法内调用 this.props，另外，注意任何 getDefaultProps() 返回的对象在实例中共享，不是复制
 ##### getInitialState  object getInitialState()  控件加载之前执行，返回值会被用于 state 的初始化值
 ##### componentWillMount（重要）  void componentWillMount()  执行一次，在初始化 render 之前执行，如果在这个方法内调用 setState，render() 知道 state 发生变化，并且执行一次
 ##### render（重要）  ReactElement render()  render 的时候 render() 会被调用
调用 render() 方法时，首先检查 this.props 和 this.state 返回一个子元素，子元素可以是 DOM 组件或者其他自定义复合控件的虚拟实现
如果不想渲染可以返回 null 或者 false，这种场景下，react 渲染一个 &amp;lt;noscript&amp;gt; 标签，当返回 null 或者 false，ReactDOM."/>
<meta name="keywords" content="HTML5, Javascript, css, front-end, blog"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://war408705279.github.io/blogs/react-component-life/" />


    <title>
        
            React component 生命周期 :: rm -rf *  — Welcome to my blog
        
    </title>



<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro" rel="stylesheet" type="text/css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://war408705279.github.io/scss/main.min.099699ab246bf26f50616f7c9f00c79d46110459d1bd727b2d07d6fc09ece082.css">



<link rel="apple-touch-icon" sizes="180x180" href="https://war408705279.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://war408705279.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://war408705279.github.io/favicon-16x16.png">
<link rel="manifest" href="https://war408705279.github.io/site.webmanifest">
<link rel="mask-icon" href="https://war408705279.github.io/safari-pinned-tab.svg" color="">
<link rel="shortcut icon" href="https://war408705279.github.io/favicon.ico">
<link rel="shortcut icon" href="https://github.githubassets.com/favicon.ico">

<meta itemprop="name" content="React component 生命周期">
<meta itemprop="description" content="React Native 中的 component 和 Android 中的 activity、fragment 等一样，存在声明周期，下面先给出 component 的生命周期图
 ##### getDefaultProps  object getDefaultProps()  执行过一次后，被创建的类会有缓存，映射的值会存在 this.props，前提是这个 prop 不是父组件指定的，这个方法在对象被创建之前执行，因此不能在方法内调用 this.props，另外，注意任何 getDefaultProps() 返回的对象在实例中共享，不是复制
 ##### getInitialState  object getInitialState()  控件加载之前执行，返回值会被用于 state 的初始化值
 ##### componentWillMount（重要）  void componentWillMount()  执行一次，在初始化 render 之前执行，如果在这个方法内调用 setState，render() 知道 state 发生变化，并且执行一次
 ##### render（重要）  ReactElement render()  render 的时候 render() 会被调用
调用 render() 方法时，首先检查 this.props 和 this.state 返回一个子元素，子元素可以是 DOM 组件或者其他自定义复合控件的虚拟实现
如果不想渲染可以返回 null 或者 false，这种场景下，react 渲染一个 &lt;noscript&gt; 标签，当返回 null 或者 false，ReactDOM.">


<meta itemprop="datePublished" content="2019-04-23T00:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2019-04-23T00:00:00&#43;08:00" />
<meta itemprop="wordCount" content="246">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://war408705279.github.io"/>

<meta name="twitter:title" content="React component 生命周期"/>
<meta name="twitter:description" content="React Native 中的 component 和 Android 中的 activity、fragment 等一样，存在声明周期，下面先给出 component 的生命周期图
 ##### getDefaultProps  object getDefaultProps()  执行过一次后，被创建的类会有缓存，映射的值会存在 this.props，前提是这个 prop 不是父组件指定的，这个方法在对象被创建之前执行，因此不能在方法内调用 this.props，另外，注意任何 getDefaultProps() 返回的对象在实例中共享，不是复制
 ##### getInitialState  object getInitialState()  控件加载之前执行，返回值会被用于 state 的初始化值
 ##### componentWillMount（重要）  void componentWillMount()  执行一次，在初始化 render 之前执行，如果在这个方法内调用 setState，render() 知道 state 发生变化，并且执行一次
 ##### render（重要）  ReactElement render()  render 的时候 render() 会被调用
调用 render() 方法时，首先检查 this.props 和 this.state 返回一个子元素，子元素可以是 DOM 组件或者其他自定义复合控件的虚拟实现
如果不想渲染可以返回 null 或者 false，这种场景下，react 渲染一个 &lt;noscript&gt; 标签，当返回 null 或者 false，ReactDOM."/>



<meta property="article:published_time" content="2019-04-23 00:00:00 &#43;0800 CST" />









    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://war408705279.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ rm -rf *</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://war408705279.github.io/blogs/">博客</a></li><li><a href="https://war408705279.github.io/movies/">电影</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://war408705279.github.io/blogs/react-component-life/">React component 生命周期</a></h2>

            

            <div class="post-content">
                <p>React Native 中的 component 和 Android 中的 activity、fragment 等一样，存在声明周期，下面先给出 component 的生命周期图</p>

<p><img src="https://war408705279.github.io/images/blogs/react-life.png" alt="react component 生命周期" title="react component 生命周期" /></p>

<ul>
<li>##### getDefaultProps</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">object</span> <span class="nx">getDefaultProps</span><span class="p">()</span>
</code></pre></div>
<p>执行过一次后，被创建的类会有缓存，映射的值会存在 this.props，前提是这个 prop 不是父组件指定的，这个方法在对象被创建之前执行，因此不能在方法内调用 this.props，另外，注意任何 getDefaultProps() 返回的对象在实例中共享，不是复制</p>

<ul>
<li>##### getInitialState</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">object</span> <span class="nx">getInitialState</span><span class="p">()</span>
</code></pre></div>
<p>控件加载之前执行，返回值会被用于 state 的初始化值</p>

<ul>
<li>##### componentWillMount（重要）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">void</span> <span class="nx">componentWillMount</span><span class="p">()</span>
</code></pre></div>
<p>执行一次，在初始化 render 之前执行，如果在这个方法内调用 setState，render() 知道 state 发生变化，并且执行一次</p>

<ul>
<li>##### render（重要）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">ReactElement</span> <span class="nx">render</span><span class="p">()</span>
</code></pre></div>
<p>render 的时候 render() 会被调用</p>

<p>调用 render() 方法时，首先检查 <em>this.props</em> 和 <em>this.state</em> 返回一个子元素，子元素可以是 DOM 组件或者其他自定义复合控件的虚拟实现</p>

<p>如果不想渲染可以返回 null 或者 false，这种场景下，react 渲染一个 &lt;noscript&gt; 标签，当返回 null 或者 false，ReactDOM.findDOMNode(this) 返回 null</p>

<p>render() 方法是很纯净的，这就意味着不要在这个方法里初始化组件的 state，每次执行时返回相同的值，不会读写 DOM 或者与服务器交互，_如果必须如服务器交互，在 componentDidMount() 方法中实现或者其他生命周期的方法中实现_，保持 render() 方法纯净使得服务器更准确，组件更简单</p>

<ul>
<li>##### componentDidMount（重要）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">void</span> <span class="nx">componentDidMount</span><span class="p">()</span>
</code></pre></div>
<p>在初始化 render 之后只执行一次，在这个方法内，可以访问任何组件，componentDidMount() 方法中的子组件在父组件之前执行</p>

<p>_从这个函数开始，就可以和 js 其他框架交互了_，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求</p>

<ul>
<li>##### shouldComponentUpdate</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">boolean</span> <span class="nx">shouldComponentUpdate</span><span class="p">(</span>
  <span class="nx">object</span> <span class="nx">nextProps</span><span class="p">,</span> <span class="nx">object</span> <span class="nx">nextState</span>
<span class="p">)</span>
</code></pre></div>
<p>这个方法在初始化 render 时不会执行，当 props 或者 state 发生变化时执行，并且是在 render 之前，当新的 props 或者 state 不需要更新组件时，返回 false</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">id</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>当 shouldComponentUpdate 方法返回 false 时，将不会执行 render() 方法， <em>componentWillUpdate</em> 和 <em>componentDidUpdate</em> 方法也不会被调用</p>

<p>默认情况下，shouldComponentUpdate 方法返回 true 防止 state 快速变化时的问题，但是如果 state 不变，props 只读，可以直接覆盖 shouldComponentUpdate 用于比较 props 和 state 的变化，决定 UI 是否更新，<em>当组件比较多时，使用这个方法能有效提高应用性能</em></p>

<ul>
<li>##### componentWillUpdate（重要）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">void</span> <span class="nx">componentWillUpdate</span><span class="p">(</span>
  <span class="nx">object</span> <span class="nx">nextProps</span><span class="p">,</span> <span class="nx">object</span> <span class="nx">nextState</span>
<span class="p">)</span>
</code></pre></div>
<p>当 props 和 state 发生变化时执行，并且在 render 方法之前执行，当然初始化 render 时不执行该方法，需要特别注意的是，在这个函数里面，就 <em>不能使用 this.setState 来修改状态</em> 。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了</p>

<ul>
<li>##### componentDidUpdate（重要）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">void</span> <span class="nx">componentDidUpdate</span><span class="p">(</span>
  <span class="nx">object</span> <span class="nx">prevProps</span><span class="p">,</span> <span class="nx">object</span> <span class="nx">prevState</span>
<span class="p">)</span>
</code></pre></div>
<p>组件更新结束之后执行，在初始化 render 时不执行</p>

<ul>
<li>##### componentWillReceiveProps</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">void</span> <span class="nx">componentWillReceiveProps</span><span class="p">(</span>
  <span class="nx">object</span> <span class="nx">nextProps</span>
<span class="p">)</span>
</code></pre></div>
<p>当 props 发生变化时执行，初始化 render 时不执行，在这个回调函数里面，可以根据属性的变化，通过调用 this.setState() 来更新组件状态，旧的属性还是可以通过 this.props 来获取，这里调用更新状态是安全的，并不会触发额外的 render 调用</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">componentWillReceiveProps</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
    <span class="nx">likesIncreasing</span><span class="o">:</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">likeCount</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">likeCount</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>##### componentWillUnmount（重要）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">void</span> <span class="nx">componentWillUnmount</span><span class="p">()</span>
</code></pre></div>
<p>当组件要被从界面上移除的时候，就会调用 componentWillUnmount()，在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p>

<ul>
<li>##### 总结</li>
</ul>

<p>以上就是 React Native 的生命周期，其中 _最上面的虚线框和右下角的虚线框的方法一定会执行_，_左下角的方法根据 props、state 是否变化去执行_，其中建议只有在 <em>componentWillMount</em> ，<em>componentDidMount</em> ， <em>componentWillReceiveProps</em> 方法中可以修改 state 值</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2019</span>
            
                <span><a href="https://war408705279.github.io">Zhazha</a></span>
            
            <span><a href="https://github.com/war408705279/" target="_blank" rel="noopener">404 Not Found</a></span>
            <span> <a href="https://war408705279.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    
</footer>

            
        </div>

        





<script type="text/javascript" src="https://war408705279.github.io/js/bundle.f65a6fe80656eb86fce3f1228faa2ac0bf43b28d21eb91975f036839ed92dfd126cabb91223501623641f4ea67ac5d03882d0b8c744da38c637a1fdf8e9016c6.js" integrity="sha512-9lpv6AZW64b84/Eij6oqwL9Dso0h65GXXwNoOe2S39EmyruRIjUBYjZB9OpnrF0DiC0LjHRNo4xjeh/fjpAWxg=="></script>



    </body>
</html>
